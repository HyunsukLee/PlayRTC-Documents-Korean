<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Tutorial - Simple Video Chat - PlayRTC Documents</title>
  

  <link rel="shortcut icon" href="../../img/favicon.ico">

  
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" href="../../css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../css/theme_extra.css" type="text/css" />
  <link rel="stylesheet" href="../../css/highlight.css">

  
  <script>
    // Current page data
    var mkdocs_page_name = "Tutorial - Simple Video Chat";
  </script>
  
  <script src="../../js/jquery-2.1.1.min.js"></script>
  <script src="../../js/modernizr-2.8.3.min.js"></script>
  <script type="text/javascript" src="../../js/highlight.pack.js"></script>
  <script src="../../js/theme.js"></script> 

  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
      <div class="wy-side-nav-search">
        <a href="../.." class="icon icon-home"> PlayRTC Documents</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        <ul class="current">
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../..">Home</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../../hello-world/">Hello PlayRTC!</a>
        
    </li>
<li>
          
            <li>
    <ul class="subnav">
    <li><span>Overview</span></li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../../overview/about/">About</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../../overview/architecture/">Architecture</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../../overview/project-key/">Project Key</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../../overview/support-environment/">Support Environment</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../../overview/feature-map/">Feature Map</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../../overview/faq/">Frequently Asked Questions</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../../overview/glossary/">Glossary</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../../overview/troubleshooting/">Trouble Shooting</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../../overview/migrate-1x-to-2x/">Migrate 1.x to 2.x</a>
        
    </li>

        
    </ul>
<li>
          
            <li>
    <ul class="subnav">
    <li><span>Browser</span></li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../../browser/dev-env/">Development Environment</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../../browser/simple-video-chat/">Tutorial - Simple Video Chat</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../../browser/ie-support/">Microsoft Internet Explorer Support</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../../browser/migrate-1x-to-2x/">Migrate 1.x to 2.x</a>
        
    </li>

        
    </ul>
<li>
          
            <li>
    <ul class="subnav">
    <li><span>Android</span></li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../../android/dev-env/">Development Environment</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../../android/simple-video-chat/">Tutorial - Simple Video Chat</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../../android/migrate-1x-to-2x/">Migrate 1.x to 2.x</a>
        
    </li>

        
    </ul>
<li>
          
            <li>
    <ul class="subnav">
    <li><span>iOS</span></li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../dev-env/">Development Environment</a>
        
    </li>

        
            
    <li class="toctree-l1 current">
        <a class="current" href="./">Tutorial - Simple Video Chat</a>
        
            <ul>
            
                <li class="toctree-l3"><a href="#ios">영상/음성 통화 iOS 앱 만들기</a></li>
                
                    <li><a class="toctree-l4" href="#playrtc-application">PlayRTC Application  주요 개발 단계</a></li>
                
                    <li><a class="toctree-l4" href="#playrtc">PlayRTC 객체 생성</a></li>
                
                    <li><a class="toctree-l4" href="#playrtcsetting">PlayRTCSetting 개체를 이용한 서비스 설정</a></li>
                
                    <li><a class="toctree-l4" href="#playrtc-p2p">PlayRTC P2P 연결을 위한 채널 서비스 입장 및 이벤트처리</a></li>
                
                    <li><a class="toctree-l4" href="#playrtc_1">PlayRTC의 미디어 스트림의 영상 출력 처리</a></li>
                
                    <li><a class="toctree-l4" href="#playrtc_2">PlayRTC 연결 종료</a></li>
                
            
            </ul>
        
    </li>

        
    </ul>
<li>
          
        </ul>
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../..">PlayRTC Documents</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../..">Docs</a> &raquo;</li>
    
      
        
          <li>iOS &raquo;</li>
        
      
    
    <li>Tutorial - Simple Video Chat</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="ios">영상/음성 통화 iOS 앱 만들기</h1>
<h2 id="playrtc-application">PlayRTC Application  주요 개발 단계</h2>
<p>PlayRTC SDK에서 가장 중요한 Class입니다. PlayRTC 클래스를 이용하여 P2P 연결에 필요한 각종 작업을 수행하고 명령을 내립니다. 또한 PlayRTCObserver 인터페이스를 구현한 클래스를 등록하여 내부의 CallBack 이벤트를 처리할 수 있습니다. 아래는 PlayRTC 클래스를 이용하여 작업하게 될 대부분의 일을 간단하게 정리하였습니다.</p>
<ol>
<li>
<p>PlayRTC 객체 생성</p>
<ul>
<li>먼저 PlayRTC 객체를 생성하려면 PlayRTCFactory의 newInstance 메소드로 객체를 생성합니다.</li>
</ul>
</li>
<li>
<p>서비스 설정</p>
<ul>
<li>PlayRTC 인터페이스를 통해서 기본 값이 설정되어 있는 PlayRTCSettings 개체를 얻어와 구현하는 서비스에 맞게  설정 값을 지정할 수 있으며, PlayRTCSettings 객체에 지정한 값은 내부적으로 PlayRTC 플랫폼 서비스에서 조회한 서비스 설정에 우선하여 적용됩니다.</li>
</ul>
</li>
<li>
<p>PlayRTC 플랫폼 서비스 채널 입장</p>
<ul>
<li>PlayRTC 플랫폼 채널 서비스에 새로운 채널을 생성하고 입장을 하거나, 기존의 만들어진 채널에 입장하여 P2P연결 수립을 수행합니다.  한 사용자는 채널을 생성하여야 하고, 다은 사용자는 만들어진 채널의 아이디로 채널에 입장을 합니다. 채널의 아이디는 PlayRTCObserver의 onConnectChannel에서 확인 할 수 있습니다.</li>
</ul>
</li>
<li>
<p>로컬미디어스트림 출력</p>
<ul>
<li>채널 서버에 연결 되면 SDK는 로컬 영상/음성 스트림을 제어를 위한 개체를 생성하여 PlayRTCObserver의 onAddLocalStream 을 통해 PlayRTCMedia인터페이스를 전달하며, 전달 받은 PlayRTCMedia에 영상 출력 뷰의 렌더러를 전달하여 영상을 출력하도록 해야 합니다.</li>
</ul>
</li>
<li>
<p>연결수립 후 원격미디어스트림 출력</p>
<ul>
<li>P2P연결 수립 후 상대방의 영상/음성 스트림을 제어를 위한 개체를 생성하여 PlayRTCObserver의 onAddRemoteStream을 통해 PlayRTCMedia인터페이스를 전달하며, 전달 받은 PlayRTCMedia에 영상 출력 뷰의 렌더러를 전달하여 영상을 출력하도록 해야 합니다.</li>
</ul>
</li>
<li>
<p>상대방과의연결종료처리</p>
<ul>
<li>PlayRTC의 disconnectChannel을 호출하여 채널에서 퇴장하거나 deleteChannel을 호출하여 채널을 종료하여 상대방과의 연결을 종료하도록합니다.</li>
</ul>
</li>
</ol>
<p>이제 좀 더 자세하게 PlayRTC 클래스를 이용하는 방법을 차근차근히 살펴보겠습니다.</p>
<h2 id="playrtc">PlayRTC 객체 생성</h2>
<p>PlayRTC SDK의 PlayRTCFactory Class의 newInstance 메소드를 이용하여 PlayRTC 객체를 생성할 수 있습니다.</p>
<p>두번째 파라미터값은 Callback 이벤트 처리를 위한 observer 클래스를 등록합니다. PlayRTCObserver 인터페이스를 구현한 클래스가 필요합니다. 이 클래스를 통해서 통신 상태에 대한 여러가지 이벤트를 수신할 수 있습니다.</p>
<p>다음과 같은 형태로 구현될 수 있습니다.</p>
<pre><code class="Objective-C">self.playRTC = [PlayRTCFactory newInstanceWithServiceUrl:url observer:(id&lt;PlayRTCObserver&gt;)self];
</code></pre>

<pre><code class="Swift">self.playRTC = PlayRTCFactory.newInstance(self as PlayRTCObserver)
</code></pre>

<h2 id="playrtcsetting">PlayRTCSetting 개체를 이용한 서비스 설정</h2>
<p>PlayRTC 객체를 생성하고 나면 getSettings() 메소드를 호출하여 PlayRTC에 설정해둔 기본적인 세팅값들을 가져올 수 있습니다. 즉 getSettings 메소드를 호출하면 PlayRTCSettings 객체를 얻을 수 있습니다. createChannel이나 connectChannel등의 메소드를 호출하는 채널작업을 하기 전에 이 객체를 수정하게 되면 수정된 값을 이용하여 채널 작업을 수행할 수 있게 됩니다.</p>
<p>PlayRTCSetting의 주요 설정 항목은 다음과 같습니다.</p>
<ul>
<li>PlayRTC 미디어 서비스 관련 설정 – 사용자 재지정</li>
<li>PlayRTC 로깅 설정 – 사용자 지정</li>
</ul>
<h3 id="playrtcsetting_1">PlayRTCSetting 개체 구하기</h3>
<p>PlayRTC 구현 객체를 생성한 후 PlayRTC의 getSettings() 메소드를 호출하여 PlayRTCSetting 개체를 얻어와 구현할 서비스에 맞게 설정 항목을 설정할 수 있습니다. PlayRTCSetting 개체는 기본값으로 초기화 되어 있는 상태입니다.</p>
<p>다음과 같은 형태로 구현할 수 있습니다.</p>
<pre><code class="Objective-C">- (void)setConfiguration {
    isClose = FALSE;

    PlayRTCSettings* settings = [self.playRTC getSettings];

    [settings setTDCProjectId:TDCPROJECTID];
    [settings setTDCHttpReferer:nil];
    [settings setVideoEnable:TRUE];
    [settings.video setFrontCameraEnable:TRUE];
    [settings.video setBackCameraEnable:FALSE];
    [settings setAudioEnable:TRUE];
    [settings setDataEnable:TRUE];
    [settings.channel setRing:FALSE];
    [settings.log.console setLevel:LOG_LEVEL];
}
</code></pre>

<pre><code class="Swift">func setPlayRTCConfiguration() {
    var settings: PlayRTCSettings
    isClose = false

    settings = self.playRTC.getSettings()

    // T Developers Project Key.
    settings.setTDCProjectId(&quot;60ba608a-e228-4530-8711-fa38004719c1&quot;)
    settings.setTDCHttpReferer(nil)
    settings.setVideoEnable(true)
    settings.video.setFrontCameraEnable(true)
    settings.video.setBackCameraEnable(false)
    settings.setAudioEnable(true)
    settings.setDataEnable(true)
    settings.channel.setRing(false)
    settings.log.console.setLevel(LOG_LEVEL)
}
</code></pre>

<h2 id="playrtc-p2p">PlayRTC P2P 연결을 위한 채널 서비스 입장 및 이벤트처리</h2>
<p>먼저 채널에 입장히는 사용자가 채널을 생성해야 하며 다른 사용자는 생성된 채널의 아이디로 채널에 입장을 하여 P2P연결을 합니다.</p>
<h3 id="user-a">신규 채널을 생성하고 입장하기 – USER A</h3>
<p>PlayRTC 플랫폼 채널 서비스에 채널을 새로 생성하고 입장하는 메소드는 PlayRTC::createChannel 입니다. 이 메소드를 호출하면 USER A를 위한 채팅방이 채널서버에 만들어진다고 보면 됩니다. 이 요청은 서비스서버를 거쳐서 채널서버로 전달됩니다. 채널서버는 채널id와 USER A에게 할당된 토큰값등을 반환해줄 것입니다. 가장 기본적인 사용법은 아무런 입력값 없이 nil을 입력하여 createChannel(nil) 메소드 호출하여 채널을 생성하는 방법이 있습니다.</p>
<p>하지만 PlayRTC는 부가적인 채널이나 peer정보등을 이 createChannel 메소드에 실어서 채널서버에  저장할 수 있도록 하고 있습니다. 즉, createChannel 호출 시 채널 및 채널 사용자의 부가 정보를 같이 전달하여 채널/사용자 정보 조회 시 받아볼 수 있습니다.</p>
<p>createChannel 메소드를 호출하면 PlayRTC는 새로 생성한 채널의 id를 PlayRTCObserver의 onConnectChannel 메소드를 통해 전달해 줍니다. 이때 전달 받은 채널id는 USER B가 connectChannel로 채널에 입장할 때 사용해야 하는  채널 아이디입니다.</p>
<p>다음과 같은 형태로 구현할 수 있습니다.</p>
<pre><code class="Objective-C">- (void)createChannel:(NSString*)chName userId:(NSString*)userId {
    if(self.playRTC == nil) {
        return;
    }

    self.channelName = chName;

    if(self.channelName == nil) self.channelName = @&quot;&quot;;

    NSMutableDictionary* parameters = [NSMutableDictionary dictionary];

    if(channelName != nil) {
        NSDictionary * channel = [NSDictionary dictionaryWithObject:chName forKey:@&quot;channelName&quot;];
        [parameters setObject:channel forKey:@&quot;channel&quot;];
    }

    if(userId != nil) {
        self.userUid = userId;
        NSDictionary * peer = [NSDictionary dictionaryWithObject:userId forKey:@&quot;uid&quot;];
        [parameters setObject:peer forKey:@&quot;peer&quot;];
    } else {
        self.userUid = @&quot;&quot;;
    }

    [self.playRTC createChannel:parameters];
}
</code></pre>

<pre><code class="Swift">func createChannel(channelId: String?, userId: String?) {
    var parameters = [String: String]()

    if self.playRTC == nil {
        return
    }

    if channelId != nil {
        parameters.updateValue(channelId!, forKey: &quot;channelId&quot;)
    }

    if userId != nil {
        self.userId = userId
        parameters.updateValue(userId!, forKey: &quot;userId&quot;)
    }

    self.playRTC.createChannel(parameters)
}
</code></pre>

<h3 id="user-b">만들어진 채널에 입장하기 – USER B</h3>
<p>이미 생성된 채널에 입장히는 메소드는 connectChannel 입니다.</p>
<p>connectChannel  호출 시  해당 채널 아이디가 필요합니다.  채널 사용자의 부가 정보를 같이 전달하여 채널/사용자  정보 조회 시 받아볼 수 있습니다. connectChannel가 잘 수행되면 onConnectChannel 메소드를 통해 보안등을 위한 채널 사용자 토큰정보등을 받을 수 있으므로 잘 보관해둬야 합니다.</p>
<p>다음과 같은 형태로 구현할 수 있습니다.</p>
<pre><code class="Objective-C">- (void)connectChannel:(NSString*)chId userId:(NSString*)userId {
    if(self.playRTC == nil) {
        return;
    }

    if(chId != nil) {
        self.channelId = chId;
    } else {
        self.channelId = @&quot;&quot;;
    }

    NSMutableDictionary* parameters = [NSMutableDictionary dictionary];

    if(userId != nil) {
        self.userUid = userId;
        NSDictionary * peer = [NSDictionary dictionaryWithObject:userId forKey:@&quot;uid&quot;];
        [parameters setObject:peer forKey:@&quot;peer&quot;];
    }

    [self.playRTC connectChannel:self.channelId parameters:parameters];
}
</code></pre>

<pre><code class="Swift">func connectChannel(channelId: String?, userId: String?) {
    var parameters = [String: String]()

    if self.playRTC == nil {
        return
    }

    if channelId != nil {
        self.channelId = channelId
    }

    if channelId != nil {
        parameters.updateValue(channelId!, forKey: &quot;channelId&quot;)
    }

    if userId != nil {
        parameters.updateValue(userId!, forKey: &quot;userId&quot;)
    }

    self.playRTC.connectChannel(self.channelId, parameters: parameters)
}
</code></pre>

<h3 id="_1">채널 입장 이벤트 받기</h3>
<p>createChannel, connectChannel을 호출하여 채널에 입장하면  PlayRTCObserver의 onConnectChannel 이 호출이되며, 입장한 채널의 아이디를 전달하게 됩니다.  onConnectChannel이 호출 될때 reason의 문자열 값으로 채널 입장 시 사용한 createChannel, connectChannel을 구분할 수 있습니다.</p>
<p>다음과 같은 형태로 구현할 수 있습니다.</p>
<pre><code class="Objective-C">-(void)onConnectChannel:(PlayRTC*)obj channelId:(NSString*)chId reason:(NSString*)reason {
    self.channelId = chId;
    [(Sample1ViewController*)self.controller onConnectChannel:chId reason:reason];
}
</code></pre>

<pre><code class="Swift">func onConnectChannel(playRTC: PlayRTC, channelId: String?, resion: String?) {
    self.channelId = channelId
}
</code></pre>

<h2 id="playrtc_1">PlayRTC의 미디어 스트림의 영상 출력 처리</h2>
<p>SDK는  영상/음성 스트림을 위한 내부 개체를 생성 후  PlayRTCMedia 인터페이스를 onAddLocalStream 또는 onAddRemoteStream 를 통해서 전달합니다. PlayRTCMedia를 전달 받으면 PlayRTCMedia객체에 영상 출력 뷰(PlayRTCVieoView)의 렌더러 인터페이스를 전달하여 영상을 출력하도록 처리해야 합니다.</p>
<h3 id="playrtcvideoview">영상 출력을 위한 PlayRTCVideoView 객체 생성</h3>
<p>PlayRTC SDK는 영상 스트림을 출력하는 PlayRTCVieoView Class를 제공합니다.
Sample 예에서는 ViewController의 viewWillAppear에서 MainRTCViewController_UILayout의 initScreenLayoutView를 호출하여 생성하도록 하였습니다.</p>
<p>뷰 배치는 상대방 스트림 View 위에 로컬 스트림을 출력하는 작은 View를 배치하도록 구성하겠습니다.</p>
<p>다음과 같은 형태로 구현할 수 있습니다..</p>
<pre><code class="Objective-C">// MainViewController.h
- (void)viewWillAppear:(BOOL)animated {
  [super viewWillAppear:animated];
  CGRect bounds = self.view.bounds;
  [self initScreenLayoutView:bounds];
}

#import &quot;PlayRTCVideoView.h&quot;

- (void) initScreenLayoutView:(CGRect)frame {
  CGRect bounds = frame;
  CGRect mainFrame = bounds;
  mainFrame.origin.y = 0;
  mainFrame.size.height = bounds.size.height;

  if([[UIDevice currentDevice] userInterfaceIdiom] == UIUserInterfaceIdiomPad) {
    mainFrame.origin.y += 30.0f;
    mainFrame.size.height -= 60.0f;
  }

  mainAreaView = [[UIView alloc] initWithFrame:mainFrame];
  mainAreaView.backgroundColor = [UIColor whiteColor];

  CGRect videoFrame = mainFrame;
  videoFrame.size.height = mainFrame.size.height;
  videoFrame.size.width = videoFrame.size.height / 0.75f;
  videoFrame.origin.y=0;

  videoAreaView = [[UIView alloc] initWithFrame:videoFrame];
  videoAreaView.center = mainAreaView.center;
  videoAreaView.backgroundColor = [UIColor brownColor];

  [self initVideoLayoutView:videoAreaView videoFrame:videoAreaView.bounds];
  [mainAreaView addSubview:videoAreaView];

  ... something_else ...
}

- (void) initVideoLayoutView:(UIView*)parent videoFrame:(CGRect)videoFrame {
  CGRect bounds = videoFrame;

  self.remoteVideoView = [[PlayRTCVideoView alloc] initWithFrame:bounds];

  CGRect localVideoFrame = videoFrame;
  localVideoFrame.size.width = localVideoFrame.size.width * 0.35;
  localVideoFrame.size.height = localVideoFrame.size.height * 0.35;
  localVideoFrame.origin.x = bounds.size.width - localVideoFrame.size.width - 10.0f;
  localVideoFrame.origin.y = 10.0f;

  self.localVideoView = [[PlayRTCVideoView alloc] initWithFrame:localVideoFrame];

  [parent addSubview:self.remoteVideoView];
  [parent addSubview:self.localVideoView];
}
</code></pre>

<pre><code class="Swift">override func viewWillAppear(animated: Bool) {
    var bounds: CGRect?

    super.viewWillAppear(animated)

    bounds = self.view.bounds

    // Make the videoView at the viewWillAppear time.
    self.initScreenLayoutView(bounds!)
}

func initScreenLayoutView(frame: CGRect) {
    var mainAreaView: UIView!
    var videoFrame: CGRect!
    var bounds: CGRect = frame
    var mainFrame: CGRect = bounds

    mainFrame.origin.y = 0
    mainFrame.size.height = bounds.size.height

    mainFrame.origin.y += 20.0
    mainFrame.size.height -= 20.0

    mainAreaView = UIView(frame: mainFrame)

    videoFrame = mainFrame

    videoAreaView = UIView(frame: videoFrame)
    videoAreaView!.backgroundColor = UIColor.brownColor()

    self.initVideoLayoutView(videoAreaView!, videoFrame: videoAreaView!.bounds)

    mainAreaView.addSubview(videoAreaView!)
}

func initVideoLayoutView(parent: UIView, videoFrame: CGRect) {
    var localVideoFrame: CGRect
    var bounds: CGRect = videoFrame

    self.remoteVideoView = PlayRTCVideoView.init(frame: bounds)

    localVideoFrame = videoFrame
    localVideoFrame.size.width = localVideoFrame.size.width * 0.35
    localVideoFrame.size.height = localVideoFrame.size.height * 0.35
    localVideoFrame.origin.x = bounds.size.width - localVideoFrame.size.width - 10.0
    localVideoFrame.origin.y = 10.0

    self.localVideoView = PlayRTCVideoView.init(frame: localVideoFrame)

    parent.addSubview(self.remoteVideoView!)
    parent.addSubview(self.localVideoView!)
}
</code></pre>

<h3 id="local-playrtcobserveronaddlocalstream">Local 영상 미디어 스트림 출력 – PlayRTCObserver.onAddLocalStream</h3>
<p>PlayRTCMedia 개체에 영상 출력 처리를 위해 PlayRTCVieoView의 렌더러 인터페이스를 전달합니다.</p>
<p>다음과 같은 형태로 구현할 수 있습니다.</p>
<pre><code class="Objective-C">#import &quot;PlayRTCMedia.h&quot;

-(void)onAddLocalStream:(PlayRTC*)obj media:(PlayRTCMedia*)media {
  self.localMedia = media;
  [media setVideoRenderer:[self.localVideoView getVideoRenderer]];
}
</code></pre>

<pre><code class="Swift">func onAddLocalStream(obj: PlayRTC!, media: PlayRTCMedia!) {
    self.localMedia = media
    media.setVideoRenderer(self.localVideoView?.getVideoRenderer())
}
</code></pre>

<h3 id="remote-playrtcobserveronaddremotestream">Remote 영상 미디어 스트림 출력 – PLayRTCObserver.onAddRemoteStream</h3>
<p>PlayRTCMedia 에 영상 출력 처리를 위해 PlayRTCVieoView의 렌더러 인터페이스를 전달합니다.</p>
<p>다음과 같은 형태로 구현할 수 있습니다.</p>
<pre><code class="Objective-C">#import &quot;PlayRTCMedia.h&quot;

-(void)onAddRemoteStream:(PlayRTC*)obj peerId:(NSString*)peerId peerUid:(NSString*)peerUid media:(PlayRTCMedia*)media {
  self.remoteMedia = media;
  [media setVideoRenderer:[self.remoteVideoView getVideoRenderer]];
}
</code></pre>

<pre><code class="Swift">func onAddRemoteStream(obj: PlayRTC!, peerId: String!, peerUid: String!, media: PlayRTCMedia!) {
    self.remoteMedia = media
    media.setVideoRenderer(self.remoteVideoView?.getVideoRenderer())
}
</code></pre>

<h2 id="playrtc_2">PlayRTC 연결 종료</h2>
<p>PlayRTC에서 상대방과 연결을 종료하는 경우는 다음의 경우가 있습니다.</p>
<h3 id="_2">상대방이 채널에서 퇴장 하는 경우 – 채널이 유효한 상태</h3>
<p>상대방이 disconnectChannel를 호출하면 SDK는 채널 서비스로부터 채널 퇴장 이벤트를 받아 채널에서 퇴장하며, 채널 서비스는 나에게 상대방의 채널 퇴장을 알리는 이벤트(onOtherDisconnectChannel)를 보내 줍니다.</p>
<h3 id="_3">자신이 채널에서 퇴장하는 경우 – 채널이 유효한 상태</h3>
<p>disconnectChannel을 호출하면 SDK는 채널 서비스로부터 채널 퇴장 이벤트(onDisconnectChannel)를 받아 채널에서 퇴장하고, 채널 서비스는 상대방에게도 나의 채널 퇴장 이벤트(onOtherDisconnectChannel)를 전달하게 됩니다. 상대방은 이 이벤트를 받아 나의 채널 퇴장을 알게 됩니다.</p>
<h3 id="_4">상대방 또는 자신이 채널을 종료 하는 경우 – 예제에서의 채널 종료 방법</h3>
<p>deleteChannel을 호출하면 채널 서비스는 채널에 입장한 모든 사용자에게 채널 종료를 통보(onDisconnectChannel)하고 채널에 있는 모든 사용자의 연결을 종료합니다. 이때 각각의 사용자는 종료하는 과정을 진행합니다.</p>
<h3 id="playrtc_3">채널 종료를 이용한 PlayRTC 연결 종료</h3>
<p>화면의 Close 버튼을 이용하여 종료과정을 구현합니다. 우선 화면에 PlayRTC를 종료하는 버튼을 생성(MainViewController_UILayout)하고 클릭 이벤트 시 PlayRTC의  deleteChannel을 호출하여 채널 종료를요청합니다.</p>
<p>채널 서비스에서 채널 종료 이벤트(MainViewController_PlayRTC의 onDeleteChannel,)를 받으면  ViewController를 종료 하도록 MainViewController의 closeApp을 호출합니다.</p>
<p>다음과 같은 형태로 구현할 수 있습니다.</p>
<pre><code class="Objective-C">[self performSelector:@selector(deleteChannel) withObject:nil afterDelay:0.1];

-(void)onDisconnectChannel:(PlayRTC*)obj reason:(NSString*)reason {
  [self closeApp];
}

-(void)closeApp {
  UIViewController* viewController = [self.navigationController popViewControllerAnimated:TRUE];
  viewController = nil;

  // A below code needs a approval of the Apple App Store
  exit(0);
}

- (void)dealloc {
  self.localMedia = nil;
  self.remoteMedia = nil;
  self.channelId = nil;
  self.token = nil;
  self.userUid = nil;

  [self.remoteVideoView removeFromSuperview];
  self.remoteVideoView = nil;
  [self.localVideoView removeFromSuperview];
  self.localVideoView = nil;

  self.playRTC = nil;
}
</code></pre>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
      
        <a href="../dev-env/" class="btn btn-neutral" title="Development Environment"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="http://www.mkdocs.org">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
	  
        </div>
      </div>

    </section>

  </div>

<div class="rst-versions" role="note" style="cursor: pointer">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
        <span><a href="../dev-env/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
    </span>
</div>

</body>
</html>
